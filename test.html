<!doctype html>
<meta charset="utf-8">
<title>Generar mapa 10000x10000</title>
<style>body{font-family:system-ui; padding:16px; background:#111; color:#eee}</style>

<button id="start">Generar mapa 10000×10000</button>
<button id="download" disabled>Descargar PNG</button>
<div id="status"></div>
<canvas id="preview" style="border:1px solid #444; margin-top:12px;"></canvas>

<script>
// ======== Config ========
const MAP_W = 10000;
const MAP_H = 10000;
const TILE = 1024;        // tamaño de tile para generar por partes (memoria)
const NOISE_SCALE = 0.0018; // controla "zoom" del ruido (ajusta)
const OCTAVES = 4;        // capas de ruido para más detalle
const PERSISTENCE = 0.5;  // amplitud relativa de cada octava

// ======== Util: RNG con semilla ========
function createRng(seed = 12345) {
  let s = seed >>> 0;
  return () => {
    s = (s + 0x6D2B79F5) | 0;
    let t = Math.imul(s ^ (s >>> 15), 1 | s);
    t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

// ======== Value noise + bilinear interp (fast, suficiente para terreno) ========
function buildNoiseGrid(gridW, gridH, rng) {
  const grid = new Float32Array((gridW + 1) * (gridH + 1));
  for (let y = 0; y <= gridH; y++) {
    for (let x = 0; x <= gridW; x++) {
      grid[y * (gridW + 1) + x] = rng();
    }
  }
  return {grid, gridW, gridH};
}

function lerp(a,b,t){return a + (b-a)*t;}
function smoothstep(t){ return t*t*(3 - 2*t); }

function sampleValueNoise(x, y, grid, freqX, freqY) {
  // x,y in continuous coordinates; freq controls grid cell size
  const gx = x * freqX;
  const gy = y * freqY;
  const ix = Math.floor(gx);
  const iy = Math.floor(gy);
  const fx = smoothstep(gx - ix);
  const fy = smoothstep(gy - iy);

  const idx = (r,c) => {
    // clamp to grid range
    const cx = Math.max(0, Math.min(grid.gridW, c));
    const cy = Math.max(0, Math.min(grid.gridH, r));
    return grid.grid[cy * (grid.gridW + 1) + cx];
  };

  const v00 = idx(iy, ix);
  const v10 = idx(iy, ix+1);
  const v01 = idx(iy+1, ix);
  const v11 = idx(iy+1, ix+1);

  const xa = lerp(v00, v10, fx);
  const xb = lerp(v01, v11, fx);
  return lerp(xa, xb, fy);
}

// ======== Multi-octave noise sample ========
function sampleNoiseOctaves(x, y, baseFreq, octaves, persistence, grids) {
  let amp = 1;
  let freq = baseFreq;
  let sum = 0;
  let norm = 0;
  for (let o=0; o<octaves; o++){
    const g = grids[o];
    sum += amp * sampleValueNoise(x, y, g, freq, freq);
    norm += amp;
    amp *= persistence;
    freq *= 2;
  }
  return sum / norm; // normalizado 0..1 (aprox)
}

// ======== Generador de tile ========
function generateTile(tileX, tileY, tileW, tileH, rngSeedBase) {
  // tileX, tileY son coordenadas en píxeles en el mapa global
  const c = document.createElement('canvas');
  c.width = tileW;
  c.height = tileH;
  const ctx = c.getContext('2d');
  const img = ctx.createImageData(tileW, tileH);
  const data = img.data;

  // Construir grids de ruido para cada octava (puede reutilizarse entre tiles si quieres)
  const grids = [];
  let rng = createRng(rngSeedBase);
  for (let o=0;o<OCTAVES;o++){
    // grid resolution proporcional a frecuencia (bajo = más grande celdas)
    const freq = NOISE_SCALE * Math.pow(2,o);
    const gridStep = Math.max(1, Math.floor(1 / freq));
    // grid dimensions que cubren la región del tile (y un borde)
    const gridW = Math.ceil((tileW + 2) / gridStep);
    const gridH = Math.ceil((tileH + 2) / gridStep);
    grids.push(buildNoiseGrid(gridW, gridH, rng));
  }

  // generar manchas: algunas posiciones y radios en coordenadas globales
  const spots = [];
  const spotCount = Math.floor(8 + rng()*20); // 8..28 manchas
  for (let s=0; s<spotCount; s++){
    const gx = Math.floor(rng() * MAP_W);
    const gy = Math.floor(rng() * MAP_H);
    const r = Math.floor(200 + rng()*900); // radios grandes para manchas
    spots.push({gx, gy, r, intensity: 0.25 + rng()*0.6});
  }

  // pintar píxeles
  for (let py=0; py<tileH; py++){
    for (let px=0; px<tileW; px++){
      const globalX = tileX + px;
      const globalY = tileY + py;

      // sample multi-octave noise
      const n = sampleNoiseOctaves(globalX, globalY, NOISE_SCALE, OCTAVES, PERSISTENCE, grids);

      // combinar con manchas: sumas algunas contribuciones si estás cerca de un spot
      let spotAdd = 0;
      for (let s=0; s<spots.length; s++){
        const sp = spots[s];
        const dx = globalX - sp.gx;
        const dy = globalY - sp.gy;
        const d2 = dx*dx + dy*dy;
        const r2 = sp.r*sp.r;
        if (d2 < r2) {
          const t = 1 - Math.sqrt(d2) / sp.r; // 0..1
          spotAdd += sp.intensity * Math.pow(t, 1.5); // caída
        }
      }
      let val = Math.min(1, Math.max(0, n + spotAdd));

      // mapear valor a color "tierra" (marrones / verde oscuro)
      // usar varios umbrales para dar variación
      let r,g,b;
      if (val < 0.35) {
        // tierra muy seca / arena
        r = 170 + val * 50; g = 130 + val * 40; b = 90 + val * 20;
      } else if (val < 0.6) {
        // tierra normal
        r = 120 + val * 80; g = 90 + val * 90; b = 60 + val * 50;
      } else {
        // manchas verdes o más oscuro
        r = 100 + val * 60; g = 110 + val * 100; b = 70 + val * 40;
      }

      // añadir un poco de ruido fino para grano
      const grain = (Math.random() - 0.5) * 8;
      r = Math.max(0, Math.min(255, r + grain));
      g = Math.max(0, Math.min(255, g + grain));
      b = Math.max(0, Math.min(255, b + grain));

      const idx = (py*tileW + px)*4;
      data[idx] = r;
      data[idx+1] = g;
      data[idx+2] = b;
      data[idx+3] = 255;
    }
  }

  ctx.putImageData(img, 0, 0);
  // devolver canvas de tile
  return c;
}

// ======== Generar mapa completo por tiles (async friendly) ========
async function generateMap() {
  const status = document.getElementById('status');
  status.textContent = 'Iniciando generación... (esto puede tardar varios segundos)';
  const outCanvas = document.createElement('canvas');
  outCanvas.width = MAP_W;
  outCanvas.height = MAP_H;
  const outCtx = outCanvas.getContext('2d');

  const cols = Math.ceil(MAP_W / TILE);
  const rows = Math.ceil(MAP_H / TILE);

  // Semilla base aleatoria
  const baseSeed = Math.floor(Math.random()*1e9);

  let processed = 0;
  for (let ry=0; ry<rows; ry++){
    for (let rx=0; rx<cols; rx++){
      const tileX = rx * TILE;
      const tileY = ry * TILE;
      const tileW = Math.min(TILE, MAP_W - tileX);
      const tileH = Math.min(TILE, MAP_H - tileY);
      status.textContent = `Generando tile ${rx+1}/${cols} × ${ry+1}/${rows} ...`;

      // generar tile (costoso)
      const tile = generateTile(tileX, tileY, tileW, tileH, baseSeed + rx*997 + ry*131);
      // dibujar tile en la salida
      outCtx.drawImage(tile, tileX, tileY);
      processed++;

      // permitir al navegador respirar y actualizar la UI
      await new Promise(r => setTimeout(r, 8));
    }
  }

  status.textContent = 'Completo. Puedes previsualizar o descargar.';
  // mostrar preview reducida en canvas de la página
  const preview = document.getElementById('preview');
  // escalar preview para que quepa (max 800px ancho)
  const maxPreview = 800;
  const scale = Math.min(1, maxPreview / MAP_W);
  preview.width = Math.floor(MAP_W * scale);
  preview.height = Math.floor(MAP_H * scale);
  const pctx = preview.getContext('2d');
  pctx.clearRect(0,0,preview.width, preview.height);
  pctx.imageSmoothingEnabled = true;
  pctx.drawImage(outCanvas, 0, 0, preview.width, preview.height);

  // activar botón de descarga creando blob
  const downloadBtn = document.getElementById('download');
  downloadBtn.disabled = false;
  downloadBtn.onclick = () => {
    outCanvas.toBlob(blob => {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'mapa-10000x10000.png';
      document.body.appendChild(a);
      a.click();
      a.remove();
    }, 'image/png');
  };
}

// ======== UI ========
document.getElementById('start').addEventListener('click', async () => {
  document.getElementById('start').disabled = true;
  await generateMap();
  document.getElementById('start').disabled = false;
});
</script>
